### Доработка

### Задача 2

> Перед выполнением задания познакомьтесь с документацией по [Redis latency troobleshooting](https://redis.io/topics/latency).
>
> Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и увеличивается пропорционально количеству реплик сервиса.
>
> При масштабировании сервиса до N реплик вы увидели, что:
>
> - сначала рост отношения записанных значений к истекшим
> - Redis блокирует операции записи
>
> Как вы думаете, в чем может быть проблема?

<p align="justify">Проблема скорей всего в том что вся память занята истекшими в один и тот же момент ключами которые еще не удаленны. Так как Redis использует в основном однопоточную конструкцию, поэтому все запросы обслуживаются последовательно, в связи с этим пока не выполнится очистка, все операции записи блокируются. </p>

----------

### Задача 4

> Перед выполнением задания ознакомьтесь со статьей [Common PostgreSQL errors](https://www.percona.com/blog/2020/06/05/10-common-postgresql-errors/) из блога Percona.
>
> Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с большим объемом данных лучше, чем MySQL.
>
> После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:
>
> ```
> postmaster invoked oom-killer
> ```
>
> Как вы думаете, что происходит?

<p align="justify"> Не хватает памяти. Когда у сервера или процесса заканчивается память, Linux предлагает 2 пути решения: обрушить всю систему или завершить процесс, который съедает память. Out-Of-Memory Killer — это процесс, который завершает приложение, чтобы спасти ядро от сбоя.</p>

> Как бы вы решили данную проблему?

<p align="justify"> Добавьте больше памяти, так же можно произвести настройку параметров, затрагивающих память в Postgres:</p>

<p align="justify"> shared_buffer - этот параметр устанавливает, сколько выделенной памяти будет использоваться PostgreSQL для кеширования.</p>

<p align="justify"> wal_buffers - PostgreSQL сначала записывает записи в WAL (журнал пред записи) в буферы, а затем эти буферы сбрасываются на диск. Размер буфера по умолчанию, определенный wal_buffers, составляет 16 МБ. Но если у нас много одновременных подключений, то более высокое значение может повысить производительность.</p>

<p align="justify"> effective_cache_size - предоставляет оценку памяти, доступной для кэширования диска. Это всего лишь ориентир, а не точный объем выделенной памяти или кеша. Он не выделяет фактическую память, но сообщает оптимизатору объем кеша, доступный в ядре. Если значение этого параметра установлено слишком низким, планировщик запросов может принять решение не использовать некоторые индексы, даже если они будут полезны. Поэтому установка большого значения всегда имеет смысл.</p>

<p align="justify"> work_mem- если нам нужно выполнить сложную сортировку, увеличьте значение work_mem для получения хороших результатов. Сортировка в памяти происходит намного быстрее, чем сортировка данных на диске. Установка очень высокого значения может стать причиной узкого места в памяти для нашей среды, поскольку этот параметр относится к операции сортировки пользователя.</p>

<p align="justify"> maintenance_work_mem - это параметр памяти, используемый для задач обслуживания.</p>

